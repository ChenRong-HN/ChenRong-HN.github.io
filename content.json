{"meta":{"title":"myblog","subtitle":"","description":"test description","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2023-11-19T14:12:24.172Z","updated":"2023-11-19T14:12:24.172Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-11-19T14:14:23.085Z","updated":"2023-11-19T14:14:23.085Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-19T14:12:02.867Z","updated":"2023-11-19T14:12:02.867Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"archives","date":"2023-11-19T13:27:06.000Z","updated":"2023-11-19T13:27:06.048Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-11-19T13:04:50.855Z","comments":true,"path":"page/index.html","permalink":"http://yoursite.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2023-11-19T14:12:51.478Z","updated":"2023-11-19T14:12:51.478Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-19T14:15:14.891Z","updated":"2023-11-19T14:15:14.891Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"SPI机制","slug":"SPI机制","date":"2024-01-17T07:56:17.000Z","updated":"2024-01-17T12:59:56.981Z","comments":true,"path":"2024/01/17/SPI机制/","link":"","permalink":"http://yoursite.com/2024/01/17/SPI%E6%9C%BA%E5%88%B6/","excerpt":"","text":"SPI 机制一、SPI机制是什么？SPI (Service Provider Interface)是JDK内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver 接口，其他不同的厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而java的SPI机制可以为某个接口寻找服务实现。java中的SPI机制主要思想是将装配的控制移到程序之外，在模块化设计中这个机制非常重要，其核心思想就是解耦 工作原理：就是ClassPath路径下的META-INF&#x2F;services文件夹中，以接口的全限定名来命名文件名，文件里面写该接口的实现。然后在资源加载的方式，读取文件的内容（接口实现的全限定名），然后再去加载类 spi可以很灵活的让接口实现分离，让api提供者只提供接口，让第三者来实现 SPI机制图如下： 优点： 使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。 缺点： 虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。 多个并发多线程使用ServiceLoader类的实例是不安全的。 针对以上缺点，我们在SPI机制选择时，可以考虑使用dubbo实现的SPI机制 SPI和API区别： API是调用并用于实现目标的类、接口、方法等的描述 SPI是扩展和实现以实现目标的类、接口、方法等的描述 二、SPI如何使用 定义一个接口 1234package com.yc.spi;public interface HelloSPI &#123; void sayHello();&#125; 完成接口的多个实现 12345678package com.yc.spi.impl;import com.yc.spi.HelloSPI;public class Hello1 implements HelloSPI &#123; @Override public void sayHello() &#123; System.out.println(&quot;test1&quot;); &#125;&#125; 12345678package com.yc.spi.impl;import com.yc.spi.HelloSPI;public class Hello2 implements HelloSPI &#123; @Override public void sayHello() &#123; System.out.println(&quot;test2&quot;); &#125;&#125; 因为在源码中明确指出了前缀META-INF/services/，所以我们需要先手工创建这个目录 然后在META-INF&#x2F;services&#x2F;目录下创建一个名称为“com.yc.spi.HelloSPI”的文件，这个文件中的内容就是这个接口的具体实现类。 文件中的内容如下： 12com.yc.spi.impl.Hello1com.yc.spi.impl.Hello2 使用ServiceLoader 来加载配置文件中指定的实现 123456789101112package com.yc.test;import com.yc.spi.HelloSPI;import java.util.ServiceLoader;public class SPIDemo &#123; public static void main(String[] args) &#123; ServiceLoader&lt;HelloSPI&gt; serviceLoader = ServiceLoader.load(HelloSPI.class); // 执行不同厂商的业务实现，具体根据业务需求配置 for (HelloSPI helloSPI : serviceLoader) &#123; helloSPI.sayHello(); &#125; &#125;&#125; 输出结果如下：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SPI","slug":"SPI","permalink":"http://yoursite.com/tags/SPI/"}]},{"title":"springboot 利用aop 完成业务异常统一处理","slug":"springboot-利用aop-完成业务异常统一处理","date":"2024-01-17T07:55:20.000Z","updated":"2024-01-17T08:03:27.274Z","comments":true,"path":"2024/01/17/springboot-利用aop-完成业务异常统一处理/","link":"","permalink":"http://yoursite.com/2024/01/17/springboot-%E5%88%A9%E7%94%A8aop-%E5%AE%8C%E6%88%90%E4%B8%9A%E5%8A%A1%E5%BC%82%E5%B8%B8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86/","excerpt":"","text":"springboot 利用aop 完成业务异常统一处理 问题描述： 如果资源的业务处理出现异常，sentinel默认的解决方案是回送一条http 500 的信息，不友好 解决方案： 123456 @RequestMapping(value = &quot;/findByPage&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)// @SentinelResource(&quot;findByPage&quot;) // 流控资源名 热点规则需要该注解配置资源名 @SentinelResource(value = &quot;findByPage&quot;,blockHandler = &quot;handleBlock&quot;, fallback = &quot;handleException&quot;) // 流控资源名 热点规则需要该注解配置资源名 public Map&lt;String,Object&gt; findByPage(@RequestParam int pageno,@RequestParam int pagesize, @RequestParam(required = false) String sortby,@RequestParam(required = false) String sort) @blockHandler 服务熔断时执行的代码逻辑（流控异常） @fallback 服务降级时执行的代码逻辑（业务异常） 当资源发生异常时，统一回调一个处理方法，重组异常信息 缺点：代码冗余，每个方法都要写相应的处理方法 引出了新问题：如果对每个资源单独指定流控回调和异常回调，则代码不友好 解决方案： 对controller中出现的异常统一处理，利用springboot的全局异常处理机制集中式处理异常 12345678910111213@ControllerAdvice // Controller控制器,ioc, Advice: aop中的增强@Order(-100000) //// AOP技术public class CustomerExceptionHandler &#123; @ExceptionHandler(RuntimeException.class) @ResponseBody public Map&lt;String,Object&gt; handleRuntimeException(RuntimeException exception)&#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(&quot;code&quot;,0); map.put(&quot;msg&quot;,&quot;runtimeException occured&quot;); return map; &#125;&#125; ​ AOP机制：Advice增强 ​ @Order(-100000) ：aop顺序，值越小在越外面 ​ @ControllerAdvice: 开启异常捕获 ​ @ExceptionHandler(RuntimeException.class)指定捕获的异常类型（例如，dao层的异常会抛到service层上，然后service层就会捕获该异常，做事务回滚，而事务回滚就是针对RuntimeException，接着抛到controller，controller也不会处理，继续往外抛，最终在这个类被拦截，统一处理） ​ @ResponseBody 返回json 对sentinel的流控异常进行统一处理，并不进入到controller中，直接在sentinel中抛出。利用springMVC的全局异常处理机制集中式处理异常 增强适配器 12345678910&lt;!--将sentinel的BlockException 抛出 到外面统一由 MySentinelExceptionHandler处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-spring-webmvc-adapter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--单独对 ParamFlowException处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-parameter-flow-control&lt;/artifactId&gt; &lt;/dependency&gt; 新增一个类完成对sentinel异常的集中处理 注意：之前必须要加上上面的依赖，否则不能对ParamFlowException进行处理 12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class MySentinelExceptionHandler implements BlockExceptionHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, BlockException ex) throws Exception &#123; String msg = null; if (ex instanceof FlowException) &#123; msg = &quot;访问频繁，请稍候再试&quot;; &#125; else if (ex instanceof DegradeException) &#123; msg = &quot;系统降级&quot;; &#125;else if( ex instanceof ParamFlowException)&#123; msg=&quot;热点参数异常:&quot;+ ex.getMessage()+&quot;,&quot;+((ParamFlowException) ex).getResourceName()+&quot;,&quot;+ex.getRule() ; &#125; else if (ex instanceof SystemBlockException) &#123; msg = &quot;系统规则限流或降级&quot;; &#125; else if (ex instanceof AuthorityException) &#123; msg = &quot;授权规则不通过&quot;; &#125; else &#123; msg = &quot;未知限流降级&quot;; &#125; // http状态码 response.setStatus(200); response.setCharacterEncoding(&quot;utf-8&quot;); response.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); Map map=new HashMap(); map.put(&quot;code&quot;,0); map. put(&quot;msg&quot;, msg); ObjectMapper om=new ObjectMapper(); String json=om.writeValueAsString( map ); PrintWriter writer=response.getWriter(); writer.write( json ); writer.flush(); &#125;&#125; 测试： 新增一个流控规则 ​ ​ ​ 可以看到，第五个请求能接收到正常数据，第六个就会接收到异常信息，并且此时的状态码都为200。 ​ @SentinelResource(“findByPage”)使用该注解设置热点流控资源名 ​ 新增一个热点流控规则： ​ ​","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"异常捕获","slug":"异常捕获","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"全局统一异常捕获和处理","slug":"全局统一异常捕获和处理","date":"2024-01-17T07:54:34.000Z","updated":"2024-01-17T08:00:17.747Z","comments":true,"path":"2024/01/17/全局统一异常捕获和处理/","link":"","permalink":"http://yoursite.com/2024/01/17/%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%92%8C%E5%A4%84%E7%90%86/","excerpt":"","text":"全局统一异常捕获和处理日常开发过程中，难免有的程序会因为某些原因抛出异常，而这些异常一般都是利用try，catch的方式处理异常或者throw，throws的方式抛出异常不管。这种方法对于程序员来说也比较麻烦，对客户来说也不太友好，所以我们希望既能方便程序员写代码，不用过多的自己去处理各种异常编写重复的代码又能提升用户的体验，这时候全局异常处理就显得很重要也很便捷了，是一种不错的选择 全局异常捕获和处理123456789@ControllerAdvicepublic class MyExceptionHandler &#123; @ExceptionHandler(value =Exception.class) public String exceptionHandler(Exception e)&#123; System.out.println(&quot;发生了一个异常&quot;+e); return e.getMessage(); &#125;&#125; @ControllerAdvice表示开启全局异常的捕获，@ExceptionHandler用来说明对哪些异常进行处理。上面这段代码意思是，只要是代码运行过程中有异常就会进行捕获，并输出这个异常。 统一结果返回与统一异常枚举类中定义了常见的错误码以及错误的提示信息。这里我们定义了统一的结果返回，其中里面的静态方法的是用来当程序异常的时候转换成异常返回规定 的格式。 123456789101112131415161718192021222324252627282930public class DefinitionException extends RuntimeException&#123; protected Integer errorCode; protected String errorMsg; public DefinitionException()&#123; &#125; public DefinitionException(Integer errorCode, String errorMsg) &#123; this.errorCode = errorCode; this.errorMsg = errorMsg; &#125; public Integer getErrorCode() &#123; return errorCode; &#125; public void setErrorCode(Integer errorCode) &#123; this.errorCode = errorCode; &#125; public String getErrorMsg() &#123; return errorMsg; &#125; public void setErrorMsg(String errorMsg) &#123; this.errorMsg = errorMsg; &#125;&#125; 其中包含了错误的状态码、错误的提示信息。然后我们可以自定义一个全局异常处理类。这样可以简化不少代码，不需要自己写try…catch来实现。 123456789101112131415161718192021222324@ControllerAdvicepublic class GlobalExceptionHandler &#123; /** * 处理自定义异常 * */ @ExceptionHandler(value = DefinitionException.class) @ResponseBody public Result bizExceptionHandler(DefinitionException e) &#123; return Result.defineError(e); &#125; /** * 处理其他异常 * */ @ExceptionHandler(value = Exception.class) @ResponseBody public Result exceptionHandler( Exception e) &#123; return Result.otherError(ErrorEnum.INTERNAL_SERVER_ERROR); &#125;&#125; @ResponseBody用于将对象解析成json，方便前后端的交互，也可以使用ResponseBody放在异常类上面。 controller 代码测试12345678910111213141516171819202122232425262728@RestController@RequestMapping(&quot;/result&quot;)public class ResultController &#123; @GetMapping(&quot;/getStudent&quot;) public Result getStudent()&#123; Student student = new Student(); student.setAge(21); student.setId(111); student.setName(&quot;学习笔记&quot;); Result result = new Result(); result.setCode(200); result.setSuccess(true); result.setData(student); result.setMsg(&quot;学生列表信息&quot;); return result; &#125; @RequestMapping(&quot;/getDeException&quot;) public Result DeException()&#123; throw new DefinitionException(400,&quot;我出错了&quot;); &#125; @RequestMapping(&quot;/getException&quot;) public Result Exception()&#123; Result result = new Result(); int a=1/0; return result; &#125;&#125; student类： 12345678910111213141516public class Student &#123; /** * 唯一标识id */ private Integer id; /** * 姓名 */ private String name; /** * 年龄 */ private Integer age;&#125; 404 异常特殊处理默认情况下，SpringBoot是不会抛出404异常的，所以ControllerAdvice也不能被捕获到，但是这个配置会让你的静态资源访问出现问题，也就是不适合前后端分离的情况。 但是我们做如下配置，就能正常访问静态资源了。 123456789@Configurationpublic class ResourceConfig implements WebMvcConfigurer &#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //可以访问localhost:8095/static/images/image.jpg registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;); &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"异常捕获","slug":"异常捕获","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"}]},{"title":"Spring Security 之Form认证.md","slug":"SpringSecurity之Form认证","date":"2024-01-17T07:48:28.000Z","updated":"2024-01-17T08:01:39.913Z","comments":true,"path":"2024/01/17/SpringSecurity之Form认证/","link":"","permalink":"http://yoursite.com/2024/01/17/SpringSecurity%E4%B9%8BForm%E8%AE%A4%E8%AF%81/","excerpt":"","text":"Spring Security 之 Form 认证spring security基于form认证与传统的区别： formLogin 登录认证不写Controller方法 传统登录认证： 请求 -&gt; 自己写controller验证用户名密码 formLogin登录认证： UsernamePasswordAuthenticationFilter UsernamePasswordAuthenticationFilter 过滤器是默认集成的，我们只需要针对它进行配置 准备工作： 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 启动类上使用@EnableWebSecurity注解开启spring security服务 进行到这里，这个项目已经启用了spring security服务，启动项目之后必须先经过认证 配置三要素 登录认证逻辑-登录URL、如何接收登录参数、登录成功后逻辑（静态） 资源访问控制-决定什么用户、什么角色可以访问什么资源（动态-数据库） 用户角色权限-配置某个用户拥有什么角色，拥有什么权限（动态-数据库） hasAuthority(“xxx”) 表示需要具有 xxx 权限 hasRole(“xxx”) 表示需要为xxx角色 角色是一种特殊的权限 hash算法 单向算法 hash值不可逆 hasAnyAuthority(“ROLE_user”,”ROLE_admin”) 等价于 hasAnyRole(“user”,”admin”) 密码组成部分：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://yoursite.com/tags/SpringSecurity/"}]},{"title":"Nacos完成服务注册与发现","slug":"Nacos完成服务注册与发现","date":"2023-11-25T09:06:09.000Z","updated":"2023-11-25T09:14:40.580Z","comments":true,"path":"2023/11/25/Nacos完成服务注册与发现/","link":"","permalink":"http://yoursite.com/2023/11/25/Nacos%E5%AE%8C%E6%88%90%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/","excerpt":"","text":"服务注册与发现的实现常见产品区分： CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性中的两项 可用性是指每个请求(成功与否)都能得到响应，不会出现错误或超时，即服务的可靠性和响应性得到保证 一致性是指所有结点在同一时间看到的数据是相同的，即数据的正确性和一致性得到保证 分区容错性是指网络发生故障或延迟时，系统仍然能够继续运行，不会挂掉，即系统的稳定性和容错性得到保证 CP：满足一致性和分区容忍性，牺牲可用性。当网络分区发生时，系统只保留一个分区继续提供服务，其他分区不可用，直到网络恢复正常。 ZooKeeper, HBase, MongoDB, Redis（集群模式）等。这些系统通常用于需要强一致性的场景，如协调、锁服务、元数据管理等 AP：满足可用性和分区容忍性，牺牲一致性。当网络分区发生时，系统保持所有分区都可用，但可能返回过期的数据，直到数据同步完成。 Eureka, Cassandra, CouchDB, DynamoDB, Riak, Redis（哨兵模式）等。这些系统通常用于需要高可用性和可扩展性的场景，如缓存、消息队列、文档存储等 Nacos是一个动态服务发现、配置管理和服务管理平台，它支持两种分布式一致性模式：AP（分区可用性）和CP（分区一致性）： AP模式是指Nacos使用自研的Distro协议来保证服务注册和发现的可用性和最终一致性，适用于临时服务节点的场景，例如Spring Cloud微服务。在AP模式下，Nacos可以容忍网络分区故障，但可能会出现数据不一致的情况。 CP模式是指Nacos使用JRaft协议来保证服务注册和发现的强一致性，适用于持久化服务节点的场景，例如Dubbo微服务。在CP模式下，Nacos可以保证数据一致性，但可能会出现服务不可用的情况。 Nacos可以根据配置或者服务节点的状态来识别为AP模式或CP模式，默认是AP模式。如果注册Nacos的client节点注册时ephemeral&#x3D;true，那么Nacos集群对这个client节点的效果就是AP，采用distro协议实现；而注册Nacos的client节点注册时ephemeral&#x3D;false，那么Nacos集群对这个client节点的效果就是CP，采用raft协议实现。 nacos各种服务的工作流程配置管理： 应用或服务可以向Nacos服务器发布或获取配置信息，如应用参数、路由规则、灰度策略等。Nacos服务器会保存配置信息到内存或数据库中，并根据长轮询的方式推送配置变更通知。 发布配置（命令模板） curl -X POST “http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld“ 获取配置（命令模板） curl -X GET “http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test“ DNS服务： 应用或服务可以向Nacos服务器查询域名对应的IP列表，实现基于DNS协议的服务发现和负载均衡。Nacos服务器会根据权重路由等策略返回IP列表，并缓存DNS记录。 元数据管理： 应用或服务可以向Nacos服务器查询或更新元数据信息，如服务描述、生命周期、依赖关系、健康状态、流量管理等。Nacos服务器会提供可视化的仪表盘和API来管理元数据信息。 服务注册发现（nacos&#x2F;eureka）: 服务注册 Nacos Client会通过发送REST请求的方式向Nacos Server注册自己的服务，提供自身的元数据，比如IP地址、端口等信息。Nacos Server接收到注册请求后，就会把这些元元数据信息存储在一个双层的内测Map中。 curl -X POST ‘http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080‘ 服务心跳（用于检测） 在服务注册后，Nacos Client会维护一个定时心跳来持续通知Nacos Server，说明服务一直处于可用状态，防止被剔除。默认5s发送一次心跳。 服务同步 –&gt; 服务集群、CAP Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。 集群：防止单点故障 服务发现 服务消费者(Nacos Client)在调用服务提供者的服务时，会发送一个REST请求给NacosServer，获取上面注册的服务清单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存 curl -X GET ‘http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName‘ 服务健康检查 Nacos Server会开启一个定时任务用来检查注册服务实例的健康情况，对于超过15s没有收到客户端心跳的实例会将它的healthy属性置为false(客户端服务发现时不会发现)，如果某个实例超过30秒没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送心跳则会重新注册) Actuator（2.X 版本）spring boot Actuator模块提供了生产级别的功能，帮助我们监控和管理spring boot应用。这个模块是一个采集应用内部信息暴露给外部的模块，上述的功能都可以通过HTTP 和 JMX 访问。 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; yml 配置： 123456management: endpoints: web: # 暴露的信息 exposure: include: &quot;health,info&quot; boot与cloud版本boot版本查看： https://spring.io/projects/spring-boot#learn cloud版本查看： https://spring.io/projects/spring-cloud#overview 版本对应表： https://start.spring.io/actuator/info alibaba与spring cloud版本对应: https://github.com/alibaba/spring-cloud-alibaba/wiki/ spring cloud alibaba版本必须依赖spring cloud版本 父项目的pom.xml中做依赖管理和版本仲裁，使用约定第三方依赖版本号，在子项目中使用继承父依赖，需要用到的依赖若父项目里有，则直接用声明，不写版本号，否则，必须写版本号。 以小萌神为例 以下导入的依赖(部分) 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;/version&gt; &lt;!-- 此依赖不会打包到最终的构件中，只影响依赖的解析过程 --&gt; &lt;type&gt;pom&lt;/type&gt; &lt;!-- 只与type=pom一起用，表示将此pom文件 中的 dependencyManagement 下的依赖信息导入当前pom --&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 通过spring-cloud-alibaba-dependencies追踪进去可以看到： ​ 这些依赖不会打包到我们的项目中，一个项目只有dependencies中的dependency才会被打包，dependencyManagement不会打包，dependencyManagement的作用是做版本管理，所以约定的类型为pom,而不是jar包。对于spring-cloud-alibaba-dependencies而言，里面只约定了所包含的依赖版本，并不意味着我们的项目要导入这些依赖，即它只是一个pom文件而不是一个jar包。总而言之，导入spring-cloud-alibaba-dependencies依赖就是意味着将该依赖的仲裁信息与我们的项目合并，从而起到增加仲裁信息的作用。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"知识点总结","slug":"学习笔记/知识点总结","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"nacos","slug":"nacos","permalink":"http://yoursite.com/tags/nacos/"},{"name":"微服务","slug":"微服务","permalink":"http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"Nacos基于SpringCloud","slug":"Nacos基于SpringCloud","date":"2023-11-25T09:05:31.000Z","updated":"2023-11-25T09:12:21.612Z","comments":true,"path":"2023/11/25/Nacos基于SpringCloud/","link":"","permalink":"http://yoursite.com/2023/11/25/Nacos%E5%9F%BA%E4%BA%8ESpringCloud/","excerpt":"","text":"Nacos基于Spring Cloud准备工作： 依赖： 12345678910111213141516171819&lt;!-- 父项目 --&gt;&lt;dependencyManagement&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.alibaba.version&#125;&lt;/version&gt; &lt;!-- 此依赖不会打包到最终的构件中，只影响依赖的解析过程 --&gt; &lt;type&gt;pom&lt;/type&gt; &lt;!-- 只与type=pom一起用，表示将此pom文件 中的 dependencyManagement 下的依赖信息导入当前pom --&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencyManagement&gt; 123456&lt;!-- 子项目 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;!-- 不需要写版本，父项目中已经将版本信息规范好了 --&gt;&lt;/dependency&gt; 注意：版本相关信息 在application.yml中配置Nacos server的地址： 配置服务提供者，从而服务提供者可以通过Nacos 的服务注册发现功能将其服务注册到服务器上 123456789spring: application: name: resfood # resfood 是此服务注册到host上的服务名 cloud: nacos: discovery: server-addr: 127.0.0.1:8848server: port: 9000 使用注解@EnableDiscoveryClient开启服务注册发现功能,如下图所示： 双击startup.cmd文件或执行以下命令启动nacos server 1startup.cmd -m standalone # 在单击模式下运行 启动本地服务器,打开浏览器通过localhost:8848&#x2F;nacos访问nacos服务(初始账号密码均为nacos) 登录之后，能够通过服务列表看到信息并且实例个数为自己手动启动的服务个数即为成功！ 可以多起几个服务自行测试！ 注意：在一个项目中多开几个服务，但是端口号是相同的。可以在VM options中通过 -DServer.port&#x3D;xxxx 命令自定义端口号进行测试！ 配置服务消费者，从而服务消费者可以通过 Nacos 的服务注册发现功能从 Nacos server 上获取到它要调用的服务。 123456789spring: application: name: resorder # resorder 是此服务注册到host上的服务名 cloud: nacos: discovery: server-addr: 127.0.0.1:8848server: port: 8000 通过注解 @EnableDiscoveryClient 开启服务注册发现功能。 启动服务，确保服务被注册，如下图即为注册成功！ 创建一个配置类 123456789@Configurationpublic class WebConfig &#123; @LoadBalanced // 负载均衡 @Bean // IOC 将 RestTemplate 对象托管到spring public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 使用@Configuration标注该类为配置类，@LoadBalanced表示引入负载均衡机制，@Bean将该对象托管到spring中。 测试服务发现 方式一 12345678@Autowired // DI private RestTemplate restTemplate; @RequestMapping(value = &quot;addCart&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) public Map&lt;String,Object&gt; addCart(@RequestParam Integer fid, @RequestParam Integer num, HttpSession session)&#123; Map&lt;String,Object&gt; result = this.restTemplate.getForObject(&quot;http://localhost:9000/resfood/findById/&quot;+ fid, Map.class); log.info(&quot;商品信息：&quot;+ result); return result; &#125; 测试（postman）： 输入地址和参数发送post请求，得到商品信息，如上图。 这里的resfood服务的端口号为9000，resorder服务的端口为8000 通过下图的日志信息可以发现，resorder服务成功向resfood发送请求拉取到数据。 总结来说就是，nacos提供一个服务端帮助我们发现、配置和管理微服务（如resfood，resorder），各个服务都需要先注册到nacos中，一个服务就能通过nacos发送请求拉取到另一个服务。就像前面的resorder通过发送请求获取商品信息，而resorder自身的订单信息又有可能是另一个服务所需，即一个服务注册到nacos中，可能是提供者也可能是消费者。 方式二 使用默认负载均衡机制: 轮询 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; 在RestTemplate上加上注解 @LoadBalanced 开启负载均衡机制，默认方式为轮询。 利用@LoadBalanced 注解（注意确保加入loadBalancer依赖），开启客户端使用服务名 resfood 来访问 123456789@Autowired // DIprivate RestTemplate restTemplate;@RequestMapping(value = &quot;addCart&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)public Map&lt;String,Object&gt; addCart(@RequestParam Integer fid, @RequestParam Integer num, HttpSession session)&#123; String url = &quot;http://resfood/resfood/findById/&quot; + fid; Map&lt;String,Object&gt; result = this.restTemplate.getForObject(url, Map.class); log.info(&quot;商品信息：&quot;+ result); return result;&#125; 启动服务后发送两次请求，结果如下图： 可以看出，第一次访问的是9001端口，第二次访问的是9000端口, 这就是轮询！。方式一中虽然加了此注解，由于没有导入上方的依赖，方法中的url地址只能采用固定的自定义9000端口，而不能通过服务名得到相应的端口号，使得轮询的效果没有得以体现。 方式三 自定义负载均衡策略，这里定义的是只选择第一个服务实例的方案： 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class OnlyOneLoadBalancer implements ReactorServiceInstanceLoadBalancer &#123; private ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider; public OnlyOneLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSuppliers)&#123; this.serviceInstanceListSupplierProvider = serviceInstanceListSuppliers; &#125; @Override public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123; ServiceInstanceListSupplier supplier = (ServiceInstanceListSupplier)this.serviceInstanceListSupplierProvider.getIfAvailable(NoopServiceInstanceListSupplier::new); return supplier.get(request).next().map((serviceInstances) -&gt; &#123; return this.processInstanceResponse(supplier, serviceInstances); &#125;); &#125; private Response&lt;ServiceInstance&gt; processInstanceResponse(ServiceInstanceListSupplier supplier, List&lt;ServiceInstance&gt; serviceInstances) &#123; Response&lt;ServiceInstance&gt; serviceInstanceResponse = this.getInstanceResponse(serviceInstances); if (supplier instanceof SelectedInstanceCallback &amp;&amp; serviceInstanceResponse.hasServer()) &#123; ((SelectedInstanceCallback)supplier).selectedServiceInstance((ServiceInstance)serviceInstanceResponse.getServer()); &#125; return serviceInstanceResponse; &#125; private Response&lt;ServiceInstance&gt; getInstanceResponse(List&lt;ServiceInstance&gt; instances) &#123; if (instances.size() == 0)&#123; log.error(&quot;instances is null&quot;); return null; &#125; // 负载均衡（算法） ServiceInstance instance = (ServiceInstance)instances.get(0); // 取第一个服务实例 return new DefaultResponse(instance); &#125;&#125; 配置类： 12345678public class MyBalancerConfinguration &#123; // ReactorServiceInstanceLoadBalancer 响应式服务实例负载均衡器 @Bean public ReactorServiceInstanceLoadBalancer myOnlyOneReactorServiceInstanceLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)&#123; String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new OnlyOneLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class)); &#125;&#125; 1234567891011121314151617@Configuration//方案一: 全局配置负载均衡策略//@LoadBalancerClient(name = &quot;resfood&quot;,configuration=&#123; MyBalancerConfinguration.class &#125;)//方案二： 对每个服务分别指定负载均衡策略@LoadBalancerClients( value = &#123; @LoadBalancerClient(value = &quot;resfood&quot;, configuration = MyBalancerConfinguration.class), @LoadBalancerClient(value = &quot;resorder&quot;, configuration = MyBalancerConfinguration.class) &#125;, defaultConfiguration = LoadBalancerClientConfiguration.class)public class WebConfig &#123; @LoadBalanced // 负载均衡 @Bean // IOC 将 RestTemplate 对象托管到spring public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 测试： 启动服务器发送两次请求后，结果如下图： 两次访问的都是服务实力列表中第一个服务 ：9000 端口，至此 ，完成！ 还想自定义其他负载均衡策略，请阅读源码了解负载均衡器实现原理！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"nacos","slug":"nacos","permalink":"http://yoursite.com/tags/nacos/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"负载均衡","slug":"负载均衡","date":"2023-11-25T09:04:53.000Z","updated":"2023-11-25T09:09:29.056Z","comments":true,"path":"2023/11/25/负载均衡/","link":"","permalink":"http://yoursite.com/2023/11/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"负载均衡什么是负载均衡负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。 举个例子来解释下负载均衡 假设，一群人在食堂排队打饭，并且只有一个窗口一个阿姨为我们打饭，人少的时候，还是可以正常完成打饭这一业务的，如果人非常多呢？一个窗口肯定是没有办法处理完这么多业务的。这就会带来一种情况，都不来食堂吃饭了，都点外卖去了。食堂肯定是不会允许这种情况发生的，这时候食堂就会想到多开几个窗口，多请几个阿姨，将原本堆积在一个窗口的业务，分配到几个窗口上，这样大家排队的时间就会大大缩短了。但是，仅仅是这样还是不够的，还是没办法保证哪个人到哪个窗口。举个例子：假设1号窗口的阿姨打饭从来不手抖，量还特别多。这样的话，大部分人不就都想着去1号窗口了吗？ 因此，食堂除了多开窗口和多请几个阿姨之外，还得规定好手机点了单之后谁该去哪个窗口取饭。 在负载均衡中，客户端（PC&#x2F;移动&#x2F;第三方）发送请求，就好比点餐的同学们，负载均衡器就好像手机上的点餐系统，接收到一个请求时， 负载均衡器就会给这个请求分配一个处理请求（取餐号），哪个窗口的阿姨叫到哪个号码，哪个人就去取。","categories":[{"name":"知识点总结","slug":"知识点总结","permalink":"http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"负载均衡","slug":"负载均衡","permalink":"http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"git 项目上传步骤及常见问题","slug":"git-项目上传步骤及常见问题","date":"2023-11-19T16:10:22.000Z","updated":"2023-11-25T09:15:49.704Z","comments":true,"path":"2023/11/20/git-项目上传步骤及常见问题/","link":"","permalink":"http://yoursite.com/2023/11/20/git-%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"git 项目上传步骤及常见问题 创建仓库 初始化 在命令行中执行 git inti 命令，生成&#x3D;&#x3D;.git&#x3D;&#x3D;文件 添加项目 运行命令 git add &lt;文件名&gt; 或者 git add . 把文件添加到git仓库中 运行命令 git commit -m “提交信息” 进行提交 将本地git 仓库与GitHub上的仓库进行关联 git remote add &lt;仓库名&#x2F;origin&gt; &lt;仓库链接&gt; 推送本地git仓库提交到GitHub上 git push -u origin master 或 git push –set-upstream &lt;仓库名&#x2F;origin&gt; master 仓库重命名之后，可以使用 git remote set-url &lt;仓库名&#x2F;origin&gt; 新的仓库URL 若项目上传失败，可能是没有正确的设置追踪关系，可以使用 git remote -v 查看当前所有的远程仓库关联。 如果没有正确设置追踪关系，可以使用 git branch –set-upstream-to&#x3D;&lt;origin&#x2F;仓库名&gt; master 手动建立本地分支与远程分支之间的关联","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"thymeleaf简单入门","slug":"thymeleaf简单入门","date":"2023-11-19T16:06:35.000Z","updated":"2023-11-25T09:16:19.789Z","comments":true,"path":"2023/11/20/thymeleaf简单入门/","link":"","permalink":"http://yoursite.com/2023/11/20/thymeleaf%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/","excerpt":"","text":"Thymeleaf 模板 类似的模板引擎还有Velocity、FreeMarker等 特点： Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 thymeleaf与jsp有点相似都是渲染模板，不同的是jsp，在没有启动服务器的时候是不能正常访问的，但是thymeleaf是在不启动Tomcat也能正常访问，jsp对页面的侵入性大，thymeleaf对页面的侵入小，在不影响到原页面的样式的情况下渲染数据。 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 使用时在html页面前加上 12&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &#x3D;&#x3D;使用时将html文件放在Resources目录下的templates目录下才可以解析到 !!!&#x3D;&#x3D; yaml 文件配置： 1234567#关闭thymeleaf缓存thymeleaf: mode: HTML cache: false# i18n 国际化messages: basename: i18n.messages # 设置国际化文件的存储位置 默认是 messages 在控制层编写代码时，使用@Controller 而不是@RestController。 @Controller 注解： @Controller 注解用于标识一个类是控制器（Controller）。它可以&#x3D;&#x3D;处理 HTTP 请求并返回相应的视图或者模型数据&#x3D;&#x3D;。 方法中通常使用 @RequestMapping、@GetMapping、@PostMapping 等注解来指定请求的 URL 和请求方法，然后可以返回视图模板或处理结果到前端页面。 该注解常用于传统的基于视图的 Web 应用程序，例如使用 Thymeleaf、JSP 或者 FreeMarker 等模板引擎来生成 HTML 视图的应用。 @RestController 注解： @RestController 注解是 @Controller 注解的变体，它&#x3D;&#x3D;专门用于构建 RESTful Web 服务&#x3D;&#x3D;。 在一个使用 @RestController 注解的类中，&#x3D;&#x3D;所有的返回值都将以 JSON 或 XML 格式直接写入 HTTP 响应体中，而不是返回视图模板&#x3D;&#x3D;。 方法中通常可以使用 @GetMapping、@PostMapping 等注解来处理相应的 HTTP 请求，并且可以使用 @ResponseBody 注解来将方法的返回值直接写入响应体中。 该注解常用于构建基于前后端分离的 Web 应用，前端通过发送HTTP请求到后端，后端返回 JSON 或 XML 格式的数据，前端通过解析这些数据来进行渲染。 如果需要将 @RestController 中的结果解析为视图，需要更改返回的数据类型。例如，可以将返回类型更改为 ModelAndView 来返回一个视图对象和相应的模型数据，并在 ModelAndView 对象中指定要使用的视图名称。也可以使用 @ResponseBody 注解来表示方法的返回值作为响应体直接写入到 HTTP 响应体中。 常见注入对象的几种方式： 12345678910&lt;!-- 方式一--&gt;&lt;h2 th:txt=&quot;$&#123;user.getUsername()&#125;&quot;&gt;&lt;/h2&gt;&lt;!-- 方式二--&gt;&lt;h2 th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/h2&gt; &lt;p th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 方式三--&gt;&lt;div th:object=&quot;$&#123;user&#125;&quot;&gt; &lt;h2 th:text=&quot;*&#123;username&#125;&quot;&gt;&lt;/h2&gt; &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt; 条件：(与vue中的v-if相似) 1&lt;p th:if=&quot;$&#123;user.isVip&#125;&quot;&gt;会员&lt;/p&gt; 循环 12345&lt;ul&gt; &lt;li th:each=&quot;tag,stat:$&#123;user.tags&#125;&quot; th:text=&quot;$&#123;tag&#125;&quot; th:classappend=&quot;$&#123;stat.last&#125;?active&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 选择 12345&lt;div th:switch=&quot;$&#123;user.sex&#125;&quot;&gt; &lt;p th:case=&quot;1&quot;&gt;男&lt;/p&gt; &lt;p th:case=&quot;2&quot;&gt;女&lt;/p&gt; &lt;p th:case=&quot;*&quot;&gt;默认&lt;/p&gt;&lt;/div&gt; 组件 创建组件 123456&lt;div th:fragment=&quot;com1&quot;&gt; 我是一号组件&lt;/div&gt;&lt;div th:fragment=&quot;com2&quot; id=&quot;com2&quot;&gt; 我是二号组件&lt;/div&gt; 引入组件 插入 1234&lt;!-- insert com2--&gt; &lt;div th:insert=&quot;~&#123;component::com2&#125;&quot;&gt;&lt;/div&gt;&lt;!-- insert id com2--&gt; &lt;div th:insert=&quot;~&#123;component::#com2&#125;&quot;&gt;&lt;/div&gt; 替换 12&lt;!-- replace com1--&gt; &lt;div th:replace=&quot;~&#123;component::com1&#125;&quot;&gt;&lt;/div&gt; Thymeleaf中的th:inline指令用于指定内联模板的模式，它的作用是在HTML标签中内嵌Thymeleaf的表达式或代码。 使用th:inline指令，可以在HTML文件中直接嵌入Thymeleaf的表达式或模板代码，使得 Thymeleaf 可以对它们进行解析和处理。 以下是th:inline指令的常见取值： th:inline=&quot;text&quot;：将标签内容视为纯文本，不进行解析。适用于需要展示一段文本而不需要Thymeleaf处理的情况。 1&lt;p th:inline=&quot;text&quot;&gt;Hello, [[$&#123;name&#125;]]!&lt;/p&gt; th:inline=&quot;none&quot;：标签中不包含Thymeleaf的表达式或代码。这是默认值，适用于不需要Thymeleaf处理的情况。 1&lt;p&gt;Hello, World!&lt;/p&gt; th:inline=&quot;javascript&quot;：将标签内容视为JavaScript代码块，可以使用Thymeleaf的表达式。 1234&lt;script th:inline=&quot;javascript&quot;&gt;var name = /*[[$&#123;name&#125;]]*/ &#x27;John&#x27;;console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);&lt;/script&gt; th:inline=&quot;xml&quot;：将标签内容视为XML片段，可以使用Thymeleaf的表达式。 123&lt;div th:inline=&quot;xml&quot;&gt;&lt;h1&gt;Hello, [[$&#123;name&#125;]]!&lt;/h1&gt;&lt;/div&gt; 使用th:inline指令可以灵活地在HTML中嵌入Thymeleaf的表达式或代码，在需要动态生成内容的场景中非常有用，例如根据后端数据生成动态的设计元素、更改文本内容等。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://yoursite.com/tags/thymeleaf/"},{"name":"模板技术","slug":"模板技术","permalink":"http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E6%8A%80%E6%9C%AF/"}]},{"title":"","slug":"promise 对象","date":"2023-11-19T15:52:43.146Z","updated":"2023-11-12T06:59:26.791Z","comments":true,"path":"2023/11/19/promise 对象/","link":"","permalink":"http://yoursite.com/2023/11/19/promise%20%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"promise 对象 ES6中Promise() 对象及then() ，catch() , race() 的原理及使用场景： 使用场景：回调函数，定时器，事件绑定， ajax 解决问题：嵌套调用的问题 session管理 :spring session+redis实现 导入依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; redis的连接配置 123456789101112131415161718192021spring: session: store-type: redis #将session保存到redis中 redis: #默认第0号数据库 database: 0 #redis默认0-15号库 host: 127.0.0.1 #使用docker后还需加上用户名和密码，且redis中配置访问的主机的ip，以提高安全性 port: 6379 password: a lettuce: pool: #最大空闲连接数 max-idle: 8 #最小空闲连接数 min-idle: 0 #最大活动连接数 max-active: 8 #最大等待时间 max-wait: -1ms #建立连接的超时时间 timeout: 3000 启用spring session @EnableRedisHttpSession","categories":[],"tags":[]},{"title":"","slug":"分布式文件服务","date":"2023-11-19T15:52:43.140Z","updated":"2023-11-17T09:09:04.614Z","comments":true,"path":"2023/11/19/分布式文件服务/","link":"","permalink":"http://yoursite.com/2023/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"分布式文件服务 安装 fastDFS 的docker 容器，在容器测试上传，测试远程访问。 12345678910111213141516171819201) tracker 安装 容器名 加入到ycnetwork 网络 docker run -d --name tracker --network=ycnetwork -v 将那个本地目录挂载到linux中 镜像名 容器名C:\\Users\\28894\\Documents\\dockercontainer\\fastdfs\\tracker:/var/fdfs delron/fastdfs tracker以上成功后 ycnetwork给tracker容器分配了 172.18.0.22) storage 安装：实际上安装了两个组件 storage + nginx（http服务器）（保证 storage的磁盘大小 至少有空闲空间 10%） 将本机的8888映射到nginx端口8888 加入到ycnetwork网络 storage将信息提交给哪个trackerdocker run -d -p 8888:8888 --name storage --network=ycnetwork -e TRACKER_SERVER=172.18.0.3:22122 -v 将那个本地目录挂载到linux中 分组C:\\Users\\28894\\Documents\\dockercontainer\\fastdfs\\storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage在storage容器中测试使用命令上传图片/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 500008.jpg测试成功后，图片保存的位置：group1/M00/00/00/rBIABWVPZ9KAV3sxAABGbuqCV2g604.jpg在浏览器中通过：http://localhost:8888/group1/M00/00/00/rBIABWVPZ9KAV3sxAABGbuqCV2g604.jpg访问到图片，则成功 编写小萌神后台 FormData对象和URLSearchParams 对象： FormData 对象： 主要用于构造表单数据，特别是用于文件上传和包含二进制数据的请求。 可以使用 append() 方法将键值对添加到 FormData 对象中。 FormData 对象会自动设置适当的请求头部，以便在发送 AJAX 请求时进行正确的数据编码和格式化。 可以通过将 FormData 对象传递给 Axios 的 data 属性来发送 Post 请求。 URLSearchParams对象： 用于构造 URL 查询参数，特别是在 GET 请求中传递参数。 可以使用 append() 方法将键值对添加到 URLSearchParams 对象中。 URLSearchParams 对象提供了一些方法（如 toString()）来处理 URL 查询参数的编码和格式化。 可以将 URLSearchParams 对象传递给 Axios 的 params 属性来发送 GET 请求。 导入fdfs依赖及相关配置 com.luhuiguo fastdfs-spring-boot-starter 0.2.0 12345fdfs: connect-timeout: 2000 so-timeout: 3000 tracker-list: - 172.18.0.4:22122 #与tracker一致 小萌神加入购物车数量异常原因(ResorderController.java) 问题：购物车中最多只能存放两件菜品 12345678910111213141516171819202122232425262728//从session中取出CartMap&lt;Integer,CartItem&gt; cart = new HashMap&lt;&gt;();if (session.getAttribute(&quot;cart&quot;) != null)&#123; cart = ((Map&lt;Integer, CartItem&gt;) session.getAttribute(&quot;cart&quot;));&#125;else&#123; session.setAttribute(&quot;cart&quot;,cart);&#125;//判断改商品是否在map中 有 修改数量 无 创建一个CartItem，存入map中CartItem ci;if (cart.containsKey(fid))&#123; ci = cart.get(fid); ci.setNum(ci.getNum()+num); cart.put(fid,ci);&#125;else &#123; ci = new CartItem(); ci.setNum(num); ci.setFood(food); cart.put(fid,ci);&#125;//处理数量if (ci.getNum() &lt;= 0)&#123; cart.remove(fid);&#125;session.setAttribute(&quot;cart&quot;,cart);//map.put(&quot;code&quot;,1);map.put(&quot;obj&quot;,cart.values());return map; 问题所在：第一次执行成功：购物车的session为null，走了else分支，成功地存放了一次数据。第二次由于session中已经存在数据，走了if分支，只在map中新增了数据并返回结果。第三次新增时，还是从session中取数据（一条数据），将新增的数据put到map中，此时返回的map中只有两条数据（第一次和第三次加入的）。 原因：只有第一次的数据存到session中，后面加入购物车的数据以临时数据的形式暂时放在map中。最后造成最多两条数据的情况 解决方法： 在每次处理完之后，将新的数据加到session中( &#x3D;&#x3D;session.setAttribute(“cart”,cart);&#x3D;&#x3D; ) ​ spring security1.token token是一种加密的字符串，包含了用户的身份和权限信息，服务器在验证用户登录后会颁发一个token给浏览器，浏览器可以选择保存位置，浏览器在每次请求时需要寿佛那个将token放在请求头中，服务器可以根据token来识别用户的身份和权限 JWT(JSON Web Token) 分为三部分：头部，载荷，签名 头部(Header)：包含了token的类型和签名算法，通常使用&#x3D;&#x3D;Base64Url编码&#x3D;&#x3D; 载荷(Payload)：包含了一些声明（Claim），可以是用户的身份和权限信息，页可以是自定义的数据通常使用&#x3D;&#x3D;Base64Url编码&#x3D;&#x3D; 签名(Signature)：使用头部和载荷以及一个密钥或者公钥&#x2F;私钥对，通过签名算法生成的字符串，用来保证token的完整性和不可伪造性 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就构成整个JWT对象TOKEN， 就可以返回给用户，形成一个类似于xxxxx.yyyyy.zzzzz的字符串 JWT依赖： 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt;&lt;/dependency&gt; jwt工具类JwtUtil.java ,实现生成和解析token，并配置好协议 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class JwtUtil &#123; public static final int EXPIRED_TOKEN=409; public static final int NO_TOKEN=410; public static final int INVALIDATE_TOKEN=411; public static long time = 1000*500; //*60*24; // token 有效期为一天 private static String signature = &quot;admin&quot;; // 生成token ，三个参数是实体类的字段，可根据自身需求来传，一般只需要用户id即可 public static String createJwtToken(String username, String role, String subject)&#123; JwtBuilder builder = Jwts.builder(); String jwtToken = builder // header .setHeaderParam(&quot;typ&quot;,&quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;,&quot;HS256&quot;) // payload 载荷 .claim(&quot;username&quot;, username) .claim(&quot;role&quot;, role) .claim(&quot;date&quot;, new Date()) .setSubject(subject) .setExpiration(new Date(System.currentTimeMillis() + time)) .setId(UUID.randomUUID().toString()) // signature 签名信息 .signWith(SignatureAlgorithm.HS256, signature) // 用.拼接 .compact(); return jwtToken; &#125; // 验证 token 是否还有效，返回具体内容 public static Claims checkToken(String token)&#123; if (token == null)&#123; return null; &#125; JwtParser parser = Jwts.parser(); try &#123; Jws&lt;Claims&gt; claimsJws = parser.setSigningKey(signature).parseClaimsJws(token); Claims claims = claimsJws.getBody(); log.info(claims.get(&quot;username&quot;).toString()); log.info(claims.get(&quot;role&quot;).toString()); log.info(claims.getId().toString()); log.info(claims.getSubject().toString()); // 签名 log.info(claims.getExpiration().toString()); // 有效期 // 如果解析 token 正常，返回 claims return claims; &#125; catch (Exception e) &#123; // 如果解析 token 抛出异常，返回 null log.error( e.getMessage() ); return null; &#125; &#125;&#125; 引入redis（存储token信息） 下载windows版redis 参考spring data redis 利用redis存登录用户的token redis中的数据可设置expiration时间 自定义请求拦截器，检验请求头中的token信息 spring security依赖 123 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"知识点总结","slug":"学习笔记/知识点总结","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"name":"知识点总结","slug":"知识点总结","permalink":"http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"SPI","slug":"SPI","permalink":"http://yoursite.com/tags/SPI/"},{"name":"异常处理","slug":"异常处理","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"异常捕获","slug":"异常捕获","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://yoursite.com/tags/SpringSecurity/"},{"name":"nacos","slug":"nacos","permalink":"http://yoursite.com/tags/nacos/"},{"name":"微服务","slug":"微服务","permalink":"http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"},{"name":"负载均衡","slug":"负载均衡","permalink":"http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://yoursite.com/tags/thymeleaf/"},{"name":"模板技术","slug":"模板技术","permalink":"http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E6%8A%80%E6%9C%AF/"}]}