{"meta":{"title":"myblog","subtitle":"","description":"test description","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"archives","date":"2023-11-19T13:27:06.000Z","updated":"2023-11-19T13:27:06.048Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-19T14:12:02.867Z","updated":"2023-11-19T14:12:02.867Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2023-11-19T14:12:24.172Z","updated":"2023-11-19T14:12:24.172Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2023-11-19T13:04:50.855Z","comments":true,"path":"page/index.html","permalink":"http://yoursite.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"","date":"2023-11-19T14:15:14.891Z","updated":"2023-11-19T14:15:14.891Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-11-19T14:12:51.478Z","updated":"2023-11-19T14:12:51.478Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-11-19T14:14:23.085Z","updated":"2023-11-19T14:14:23.085Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"git 项目上传步骤及常见问题","slug":"git-项目上传步骤及常见问题","date":"2023-11-19T16:10:22.000Z","updated":"2023-11-19T16:12:02.762Z","comments":true,"path":"2023/11/20/git-项目上传步骤及常见问题/","link":"","permalink":"http://yoursite.com/2023/11/20/git-%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"git 项目上传步骤及常见问题 创建仓库 初始化 在命令行中执行 git inti 命令，生成&#x3D;&#x3D;.git&#x3D;&#x3D;文件 添加项目 运行命令 git add &lt;文件名&gt; 或者 git add . 把文件添加到git仓库中 运行命令 git commit -m “提交信息” 进行提交 将本地git 仓库与GitHub上的仓库进行关联 git remote add &lt;仓库名&#x2F;origin&gt; &lt;仓库链接&gt; 推送本地git仓库提交到GitHub上 git push -u origin master 或 git push –set-upstream &lt;仓库名&#x2F;origin&gt; master 仓库重命名之后，可以使用 git remote set-url &lt;仓库名&#x2F;origin&gt; 新的仓库URL 若项目上传失败，可能是没有正确的设置追踪关系，可以使用 git remote -v 查看当前所有的远程仓库关联。 如果没有正确设置追踪关系，可以使用 git branch –set-upstream-to&#x3D;&lt;origin&#x2F;仓库名&gt; master 手动建立本地分支与远程分支之间的关联","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"github","slug":"git/github","permalink":"http://yoursite.com/categories/git/github/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"thymeleaf简单入门","slug":"thymeleaf简单入门","date":"2023-11-19T16:06:35.000Z","updated":"2023-11-19T16:08:36.694Z","comments":true,"path":"2023/11/20/thymeleaf简单入门/","link":"","permalink":"http://yoursite.com/2023/11/20/thymeleaf%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/","excerpt":"","text":"Thymeleaf 模板 类似的模板引擎还有Velocity、FreeMarker等 特点： Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 thymeleaf与jsp有点相似都是渲染模板，不同的是jsp，在没有启动服务器的时候是不能正常访问的，但是thymeleaf是在不启动Tomcat也能正常访问，jsp对页面的侵入性大，thymeleaf对页面的侵入小，在不影响到原页面的样式的情况下渲染数据。 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 使用时在html页面前加上 12&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &#x3D;&#x3D;使用时将html文件放在Resources目录下的templates目录下才可以解析到 !!!&#x3D;&#x3D; yaml 文件配置： 1234567#关闭thymeleaf缓存thymeleaf: mode: HTML cache: false# i18n 国际化messages: basename: i18n.messages # 设置国际化文件的存储位置 默认是 messages 在控制层编写代码时，使用@Controller 而不是@RestController。 @Controller 注解： @Controller 注解用于标识一个类是控制器（Controller）。它可以&#x3D;&#x3D;处理 HTTP 请求并返回相应的视图或者模型数据&#x3D;&#x3D;。 方法中通常使用 @RequestMapping、@GetMapping、@PostMapping 等注解来指定请求的 URL 和请求方法，然后可以返回视图模板或处理结果到前端页面。 该注解常用于传统的基于视图的 Web 应用程序，例如使用 Thymeleaf、JSP 或者 FreeMarker 等模板引擎来生成 HTML 视图的应用。 @RestController 注解： @RestController 注解是 @Controller 注解的变体，它&#x3D;&#x3D;专门用于构建 RESTful Web 服务&#x3D;&#x3D;。 在一个使用 @RestController 注解的类中，&#x3D;&#x3D;所有的返回值都将以 JSON 或 XML 格式直接写入 HTTP 响应体中，而不是返回视图模板&#x3D;&#x3D;。 方法中通常可以使用 @GetMapping、@PostMapping 等注解来处理相应的 HTTP 请求，并且可以使用 @ResponseBody 注解来将方法的返回值直接写入响应体中。 该注解常用于构建基于前后端分离的 Web 应用，前端通过发送HTTP请求到后端，后端返回 JSON 或 XML 格式的数据，前端通过解析这些数据来进行渲染。 如果需要将 @RestController 中的结果解析为视图，需要更改返回的数据类型。例如，可以将返回类型更改为 ModelAndView 来返回一个视图对象和相应的模型数据，并在 ModelAndView 对象中指定要使用的视图名称。也可以使用 @ResponseBody 注解来表示方法的返回值作为响应体直接写入到 HTTP 响应体中。 常见注入对象的几种方式： 12345678910&lt;!-- 方式一--&gt;&lt;h2 th:txt=&quot;$&#123;user.getUsername()&#125;&quot;&gt;&lt;/h2&gt;&lt;!-- 方式二--&gt;&lt;h2 th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/h2&gt; &lt;p th:text=&quot;$&#123;user.age&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 方式三--&gt;&lt;div th:object=&quot;$&#123;user&#125;&quot;&gt; &lt;h2 th:text=&quot;*&#123;username&#125;&quot;&gt;&lt;/h2&gt; &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt; 条件：(与vue中的v-if相似) 1&lt;p th:if=&quot;$&#123;user.isVip&#125;&quot;&gt;会员&lt;/p&gt; 循环 12345&lt;ul&gt; &lt;li th:each=&quot;tag,stat:$&#123;user.tags&#125;&quot; th:text=&quot;$&#123;tag&#125;&quot; th:classappend=&quot;$&#123;stat.last&#125;?active&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 选择 12345&lt;div th:switch=&quot;$&#123;user.sex&#125;&quot;&gt; &lt;p th:case=&quot;1&quot;&gt;男&lt;/p&gt; &lt;p th:case=&quot;2&quot;&gt;女&lt;/p&gt; &lt;p th:case=&quot;*&quot;&gt;默认&lt;/p&gt;&lt;/div&gt; 组件 创建组件 123456&lt;div th:fragment=&quot;com1&quot;&gt; 我是一号组件&lt;/div&gt;&lt;div th:fragment=&quot;com2&quot; id=&quot;com2&quot;&gt; 我是二号组件&lt;/div&gt; 引入组件 插入 1234&lt;!-- insert com2--&gt; &lt;div th:insert=&quot;~&#123;component::com2&#125;&quot;&gt;&lt;/div&gt;&lt;!-- insert id com2--&gt; &lt;div th:insert=&quot;~&#123;component::#com2&#125;&quot;&gt;&lt;/div&gt; 替换 12&lt;!-- replace com1--&gt; &lt;div th:replace=&quot;~&#123;component::com1&#125;&quot;&gt;&lt;/div&gt; Thymeleaf中的th:inline指令用于指定内联模板的模式，它的作用是在HTML标签中内嵌Thymeleaf的表达式或代码。 使用th:inline指令，可以在HTML文件中直接嵌入Thymeleaf的表达式或模板代码，使得 Thymeleaf 可以对它们进行解析和处理。 以下是th:inline指令的常见取值： th:inline=&quot;text&quot;：将标签内容视为纯文本，不进行解析。适用于需要展示一段文本而不需要Thymeleaf处理的情况。 1&lt;p th:inline=&quot;text&quot;&gt;Hello, [[$&#123;name&#125;]]!&lt;/p&gt; th:inline=&quot;none&quot;：标签中不包含Thymeleaf的表达式或代码。这是默认值，适用于不需要Thymeleaf处理的情况。 1&lt;p&gt;Hello, World!&lt;/p&gt; th:inline=&quot;javascript&quot;：将标签内容视为JavaScript代码块，可以使用Thymeleaf的表达式。 1234&lt;script th:inline=&quot;javascript&quot;&gt;var name = /*[[$&#123;name&#125;]]*/ &#x27;John&#x27;;console.log(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);&lt;/script&gt; th:inline=&quot;xml&quot;：将标签内容视为XML片段，可以使用Thymeleaf的表达式。 123&lt;div th:inline=&quot;xml&quot;&gt;&lt;h1&gt;Hello, [[$&#123;name&#125;]]!&lt;/h1&gt;&lt;/div&gt; 使用th:inline指令可以灵活地在HTML中嵌入Thymeleaf的表达式或代码，在需要动态生成内容的场景中非常有用，例如根据后端数据生成动态的设计元素、更改文本内容等。","categories":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://yoursite.com/categories/thymeleaf/"}],"tags":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://yoursite.com/tags/thymeleaf/"}]},{"title":"","slug":"promise 对象","date":"2023-11-19T15:52:43.146Z","updated":"2023-11-12T06:59:26.791Z","comments":true,"path":"2023/11/19/promise 对象/","link":"","permalink":"http://yoursite.com/2023/11/19/promise%20%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"promise 对象 ES6中Promise() 对象及then() ，catch() , race() 的原理及使用场景： 使用场景：回调函数，定时器，事件绑定， ajax 解决问题：嵌套调用的问题 session管理 :spring session+redis实现 导入依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; redis的连接配置 123456789101112131415161718192021spring: session: store-type: redis #将session保存到redis中 redis: #默认第0号数据库 database: 0 #redis默认0-15号库 host: 127.0.0.1 #使用docker后还需加上用户名和密码，且redis中配置访问的主机的ip，以提高安全性 port: 6379 password: a lettuce: pool: #最大空闲连接数 max-idle: 8 #最小空闲连接数 min-idle: 0 #最大活动连接数 max-active: 8 #最大等待时间 max-wait: -1ms #建立连接的超时时间 timeout: 3000 启用spring session @EnableRedisHttpSession","categories":[],"tags":[]},{"title":"","slug":"分布式文件服务","date":"2023-11-19T15:52:43.140Z","updated":"2023-11-17T09:09:04.614Z","comments":true,"path":"2023/11/19/分布式文件服务/","link":"","permalink":"http://yoursite.com/2023/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"分布式文件服务 安装 fastDFS 的docker 容器，在容器测试上传，测试远程访问。 12345678910111213141516171819201) tracker 安装 容器名 加入到ycnetwork 网络 docker run -d --name tracker --network=ycnetwork -v 将那个本地目录挂载到linux中 镜像名 容器名C:\\Users\\28894\\Documents\\dockercontainer\\fastdfs\\tracker:/var/fdfs delron/fastdfs tracker以上成功后 ycnetwork给tracker容器分配了 172.18.0.22) storage 安装：实际上安装了两个组件 storage + nginx（http服务器）（保证 storage的磁盘大小 至少有空闲空间 10%） 将本机的8888映射到nginx端口8888 加入到ycnetwork网络 storage将信息提交给哪个trackerdocker run -d -p 8888:8888 --name storage --network=ycnetwork -e TRACKER_SERVER=172.18.0.3:22122 -v 将那个本地目录挂载到linux中 分组C:\\Users\\28894\\Documents\\dockercontainer\\fastdfs\\storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage在storage容器中测试使用命令上传图片/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 500008.jpg测试成功后，图片保存的位置：group1/M00/00/00/rBIABWVPZ9KAV3sxAABGbuqCV2g604.jpg在浏览器中通过：http://localhost:8888/group1/M00/00/00/rBIABWVPZ9KAV3sxAABGbuqCV2g604.jpg访问到图片，则成功 编写小萌神后台 FormData对象和URLSearchParams 对象： FormData 对象： 主要用于构造表单数据，特别是用于文件上传和包含二进制数据的请求。 可以使用 append() 方法将键值对添加到 FormData 对象中。 FormData 对象会自动设置适当的请求头部，以便在发送 AJAX 请求时进行正确的数据编码和格式化。 可以通过将 FormData 对象传递给 Axios 的 data 属性来发送 Post 请求。 URLSearchParams对象： 用于构造 URL 查询参数，特别是在 GET 请求中传递参数。 可以使用 append() 方法将键值对添加到 URLSearchParams 对象中。 URLSearchParams 对象提供了一些方法（如 toString()）来处理 URL 查询参数的编码和格式化。 可以将 URLSearchParams 对象传递给 Axios 的 params 属性来发送 GET 请求。 导入fdfs依赖及相关配置 com.luhuiguo fastdfs-spring-boot-starter 0.2.0 12345fdfs: connect-timeout: 2000 so-timeout: 3000 tracker-list: - 172.18.0.4:22122 #与tracker一致 小萌神加入购物车数量异常原因(ResorderController.java) 问题：购物车中最多只能存放两件菜品 12345678910111213141516171819202122232425262728//从session中取出CartMap&lt;Integer,CartItem&gt; cart = new HashMap&lt;&gt;();if (session.getAttribute(&quot;cart&quot;) != null)&#123; cart = ((Map&lt;Integer, CartItem&gt;) session.getAttribute(&quot;cart&quot;));&#125;else&#123; session.setAttribute(&quot;cart&quot;,cart);&#125;//判断改商品是否在map中 有 修改数量 无 创建一个CartItem，存入map中CartItem ci;if (cart.containsKey(fid))&#123; ci = cart.get(fid); ci.setNum(ci.getNum()+num); cart.put(fid,ci);&#125;else &#123; ci = new CartItem(); ci.setNum(num); ci.setFood(food); cart.put(fid,ci);&#125;//处理数量if (ci.getNum() &lt;= 0)&#123; cart.remove(fid);&#125;session.setAttribute(&quot;cart&quot;,cart);//map.put(&quot;code&quot;,1);map.put(&quot;obj&quot;,cart.values());return map; 问题所在：第一次执行成功：购物车的session为null，走了else分支，成功地存放了一次数据。第二次由于session中已经存在数据，走了if分支，只在map中新增了数据并返回结果。第三次新增时，还是从session中取数据（一条数据），将新增的数据put到map中，此时返回的map中只有两条数据（第一次和第三次加入的）。 原因：只有第一次的数据存到session中，后面加入购物车的数据以临时数据的形式暂时放在map中。最后造成最多两条数据的情况 解决方法： 在每次处理完之后，将新的数据加到session中( &#x3D;&#x3D;session.setAttribute(“cart”,cart);&#x3D;&#x3D; ) ​ spring security1.token token是一种加密的字符串，包含了用户的身份和权限信息，服务器在验证用户登录后会颁发一个token给浏览器，浏览器可以选择保存位置，浏览器在每次请求时需要寿佛那个将token放在请求头中，服务器可以根据token来识别用户的身份和权限 JWT(JSON Web Token) 分为三部分：头部，载荷，签名 头部(Header)：包含了token的类型和签名算法，通常使用&#x3D;&#x3D;Base64Url编码&#x3D;&#x3D; 载荷(Payload)：包含了一些声明（Claim），可以是用户的身份和权限信息，页可以是自定义的数据通常使用&#x3D;&#x3D;Base64Url编码&#x3D;&#x3D; 签名(Signature)：使用头部和载荷以及一个密钥或者公钥&#x2F;私钥对，通过签名算法生成的字符串，用来保证token的完整性和不可伪造性 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就构成整个JWT对象TOKEN， 就可以返回给用户，形成一个类似于xxxxx.yyyyy.zzzzz的字符串 JWT依赖： 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.7.0&lt;/version&gt;&lt;/dependency&gt; jwt工具类JwtUtil.java ,实现生成和解析token，并配置好协议 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class JwtUtil &#123; public static final int EXPIRED_TOKEN=409; public static final int NO_TOKEN=410; public static final int INVALIDATE_TOKEN=411; public static long time = 1000*500; //*60*24; // token 有效期为一天 private static String signature = &quot;admin&quot;; // 生成token ，三个参数是实体类的字段，可根据自身需求来传，一般只需要用户id即可 public static String createJwtToken(String username, String role, String subject)&#123; JwtBuilder builder = Jwts.builder(); String jwtToken = builder // header .setHeaderParam(&quot;typ&quot;,&quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;,&quot;HS256&quot;) // payload 载荷 .claim(&quot;username&quot;, username) .claim(&quot;role&quot;, role) .claim(&quot;date&quot;, new Date()) .setSubject(subject) .setExpiration(new Date(System.currentTimeMillis() + time)) .setId(UUID.randomUUID().toString()) // signature 签名信息 .signWith(SignatureAlgorithm.HS256, signature) // 用.拼接 .compact(); return jwtToken; &#125; // 验证 token 是否还有效，返回具体内容 public static Claims checkToken(String token)&#123; if (token == null)&#123; return null; &#125; JwtParser parser = Jwts.parser(); try &#123; Jws&lt;Claims&gt; claimsJws = parser.setSigningKey(signature).parseClaimsJws(token); Claims claims = claimsJws.getBody(); log.info(claims.get(&quot;username&quot;).toString()); log.info(claims.get(&quot;role&quot;).toString()); log.info(claims.getId().toString()); log.info(claims.getSubject().toString()); // 签名 log.info(claims.getExpiration().toString()); // 有效期 // 如果解析 token 正常，返回 claims return claims; &#125; catch (Exception e) &#123; // 如果解析 token 抛出异常，返回 null log.error( e.getMessage() ); return null; &#125; &#125;&#125; 引入redis（存储token信息） 下载windows版redis 参考spring data redis 利用redis存登录用户的token redis中的数据可设置expiration时间 自定义请求拦截器，检验请求头中的token信息 spring security依赖 123 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[],"tags":[]}],"categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"github","slug":"git/github","permalink":"http://yoursite.com/categories/git/github/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://yoursite.com/categories/thymeleaf/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://yoursite.com/tags/thymeleaf/"}]}